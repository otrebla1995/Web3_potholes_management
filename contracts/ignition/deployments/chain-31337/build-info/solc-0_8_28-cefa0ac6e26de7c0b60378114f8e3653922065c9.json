{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-cefa0ac6e26de7c0b60378114f8e3653922065c9",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/PotholesRegistry.sol": "project/contracts/PotholesRegistry.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/metatx/ERC2771Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (metatx/ERC2771Context.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Context variant with ERC-2771 support.\n *\n * WARNING: Avoid using this pattern in contracts that rely in a specific calldata length as they'll\n * be affected by any forwarder whose `msg.data` is suffixed with the `from` address according to the ERC-2771\n * specification adding the address size in bytes (20) to the calldata size. An example of an unexpected\n * behavior could be an unintended fallback (or another function) invocation while trying to invoke the `receive`\n * function only accessible if `msg.data.length == 0`.\n *\n * WARNING: The usage of `delegatecall` in this contract is dangerous and may result in context corruption.\n * Any forwarded request to this contract triggering a `delegatecall` to itself will result in an invalid {_msgSender}\n * recovery.\n */\nabstract contract ERC2771Context is Context {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _trustedForwarder;\n\n    /**\n     * @dev Initializes the contract with a trusted forwarder, which will be able to\n     * invoke functions on this contract on behalf of other accounts.\n     *\n     * NOTE: The trusted forwarder can be replaced by overriding {trustedForwarder}.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address trustedForwarder_) {\n        _trustedForwarder = trustedForwarder_;\n    }\n\n    /**\n     * @dev Returns the address of the trusted forwarder.\n     */\n    function trustedForwarder() public view virtual returns (address) {\n        return _trustedForwarder;\n    }\n\n    /**\n     * @dev Indicates whether any particular address is the trusted forwarder.\n     */\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == trustedForwarder();\n    }\n\n    /**\n     * @dev Override for `msg.sender`. Defaults to the original `msg.sender` whenever\n     * a call is not performed by the trusted forwarder or the calldata length is less than\n     * 20 bytes (an address length).\n     */\n    function _msgSender() internal view virtual override returns (address) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (calldataLength >= contextSuffixLength && isTrustedForwarder(msg.sender)) {\n            unchecked {\n                return address(bytes20(msg.data[calldataLength - contextSuffixLength:]));\n            }\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    /**\n     * @dev Override for `msg.data`. Defaults to the original `msg.data` whenever\n     * a call is not performed by the trusted forwarder or the calldata length is less than\n     * 20 bytes (an address length).\n     */\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (calldataLength >= contextSuffixLength && isTrustedForwarder(msg.sender)) {\n            unchecked {\n                return msg.data[:calldataLength - contextSuffixLength];\n            }\n        } else {\n            return super._msgData();\n        }\n    }\n\n    /**\n     * @dev ERC-2771 specifies the context as being a single address (20 bytes).\n     */\n    function _contextSuffixLength() internal view virtual override returns (uint256) {\n        return 20;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/contracts/PotholesRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\ninterface IPotholesToken {\n    function mint(address to, uint256 amount) external;\n}\n\ncontract PotholesRegistry is ERC2771Context, Ownable, ReentrancyGuard {\n    // Structs\n    struct PotholeReport {\n        uint256 id;\n        int256 latitude;\n        int256 longitude;\n        string ipfsHash;\n        uint256 duplicateCount;\n        uint256 reportedAt;\n        address reporter;\n        PotholeStatus status;\n    }\n\n    enum PotholeStatus {\n        Reported,\n        InProgress, \n        Completed,\n        Rejected\n    }\n\n    // State variables\n    IPotholesToken public immutable potholeToken;\n    string public cityName;\n    uint256 public nextReportId = 1;\n\n    // Grid configuration - city-specific\n    int256 public immutable cityMinLat;\n    int256 public immutable cityMaxLat;  \n    int256 public immutable cityMinLng;\n    int256 public immutable cityMaxLng;\n    uint256 public immutable grid_precision; // Coordinate units per grid cell\n\n    modifier withinCityBounds(int256 lat, int256 lng) {\n        require(lat >= cityMinLat && lat <= cityMaxLat, \"Latitude outside city bounds\");\n        require(lng >= cityMinLng && lng <= cityMaxLng, \"Longitude outside city bounds\");\n        _;\n    }\n\n    // Rewards (in wei, considering token decimals)\n    uint256 public originalReportReward = 10 * 10**18; // 10 PBC\n    uint256 public duplicateReporterReward = 2 * 10**18; // 2 PBC  \n    uint256 public originalReportFixedReward = 5 * 10**18; // 1 PBC bonus to original reporter\n    \n    // Storage mappings\n    mapping(uint256 => PotholeReport) public reports;\n    mapping(bytes32 => uint256) public locationToReportId; // Location hash → report ID\n    mapping(address => bool) public registeredCitizens;\n    mapping(address => mapping(uint256 => bool)) public userReportedLocation; // user → reportId → hasReported\n    mapping(address => bool) public authorizedMunicipals; // Municipal authorities\n    \n    uint256 public citizenCount;\n    uint256 public totalReports;\n    \n    // Events\n    event CitizenRegistered(address indexed citizen);\n    event CitizensBatchRegistered(address[] citizens);\n    event MunicipalAuthorityAdded(address indexed authority);\n    event MunicipalAuthorityRemoved(address indexed authority);\n    \n    event PotholeReported(\n        uint256 indexed reportId,\n        address indexed reporter,\n        int256 latitude,\n        int256 longitude,\n        string ipfsHash\n    );\n    \n    event DuplicateReported(\n        uint256 indexed originalReportId,\n        address indexed duplicateReporter,\n        uint256 newDuplicateCount,\n        int256 latitude,\n        int256 longitude,\n        string ipfsHash\n    );\n    \n    event PotholeStatusUpdated(\n        uint256 indexed reportId,\n        PotholeStatus oldStatus,\n        PotholeStatus newStatus,\n        address indexed updatedBy\n    );\n\n    event PotholeRejected(\n        uint256 indexed reportId,\n        address indexed rejectedBy,\n        string reason\n    );\n\n    event RewardSettingsUpdated(\n        uint256 originalReportReward,\n        uint256 duplicateReporterReward,\n        uint256 duplicateOriginalBonus\n    );\n\n    // Modifiers\n    modifier onlyRegisteredCitizen() {\n        require(registeredCitizens[_msgSender()], \"Not registered citizen\");\n        _;\n    }\n    \n    modifier onlyMunicipalAuthority() {\n        require(authorizedMunicipals[_msgSender()], \"Not authorized municipal authority\");\n        _;\n    }\n    \n    modifier validReportId(uint256 reportId) {\n        require(reportId > 0 && reportId < nextReportId, \"Invalid report ID\");\n        _;\n    }\n\n    // Constructor\n    constructor(\n        string memory _cityName,\n        address _potholeToken,\n        address _trustedForwarder,\n        address _initialOwner,\n        int256 _cityMinLat,\n        int256 _cityMaxLat,\n        int256 _cityMinLng,\n        int256 _cityMaxLng,\n        uint256 _gridPrecision\n    ) ERC2771Context(_trustedForwarder) Ownable(_initialOwner) {\n        cityName = _cityName;\n        potholeToken = IPotholesToken(_potholeToken);\n        cityMinLat = _cityMinLat;\n        cityMaxLat = _cityMaxLat;\n        cityMinLng = _cityMinLng;\n        cityMaxLng = _cityMaxLng;\n        grid_precision = _gridPrecision;\n    }\n\n    // Citizen Management Functions\n    function addCitizen(address citizen) external onlyOwner {\n        require(!registeredCitizens[citizen], \"Citizen already registered\");\n        registeredCitizens[citizen] = true;\n        citizenCount++;\n        emit CitizenRegistered(citizen);\n    }\n    \n    function addCitizensBatch(address[] calldata citizens) external onlyOwner {\n        for (uint256 i = 0; i < citizens.length; i++) {\n            if (!registeredCitizens[citizens[i]]) {\n                registeredCitizens[citizens[i]] = true;\n                citizenCount++;\n            }\n        }\n        emit CitizensBatchRegistered(citizens);\n    }\n    \n    function removeCitizen(address citizen) external onlyOwner {\n        require(registeredCitizens[citizen], \"Citizen not registered\");\n        registeredCitizens[citizen] = false;\n        citizenCount--;\n    }\n\n    // Municipal Authority Management\n    function addMunicipalAuthority(address authority) external onlyOwner {\n        authorizedMunicipals[authority] = true;\n        emit MunicipalAuthorityAdded(authority);\n    }\n    \n    function removeMunicipalAuthority(address authority) external onlyOwner {\n        authorizedMunicipals[authority] = false;\n        emit MunicipalAuthorityRemoved(authority);\n    }\n\n    // Core Reporting Functions\n    function submitReport(\n        int256 latitude,\n        int256 longitude,\n        string calldata ipfsHash\n    ) external onlyRegisteredCitizen withinCityBounds(latitude, longitude) nonReentrant returns (uint256) {\n        require(bytes(ipfsHash).length > 0, \"IPFS hash required\");\n\n        bytes32 locationHash = _getLocationHash(latitude, longitude);\n        uint256 existingReportId = locationToReportId[locationHash];\n        PotholeStatus status = reports[existingReportId].status;\n\n        require(status != PotholeStatus.InProgress, \"Cannot report location in progress\");\n\n        if (existingReportId != 0 && (status != PotholeStatus.Rejected && status != PotholeStatus.Completed)) {\n            // This is a duplicate report\n            require(!userReportedLocation[_msgSender()][existingReportId], \n                    \"You already reported this pothole\");\n            \n            // Mark user as having reported this location\n            userReportedLocation[_msgSender()][existingReportId] = true;\n            \n            // Increment duplicate counter\n            reports[existingReportId].duplicateCount++;\n            \n            // Emit duplicate event (no storage of duplicate data)\n            emit DuplicateReported(\n                existingReportId,\n                _msgSender(),\n                reports[existingReportId].duplicateCount,\n                latitude,\n                longitude,\n                ipfsHash\n            );\n            \n            return existingReportId;\n            \n        } else {\n            // New unique report\n            uint256 reportId = nextReportId++;\n            \n            reports[reportId] = PotholeReport({\n                id: reportId,\n                latitude: latitude,\n                longitude: longitude,\n                ipfsHash: ipfsHash,\n                duplicateCount: 0,\n                reportedAt: block.timestamp,\n                reporter: _msgSender(),\n                status: PotholeStatus.Reported\n            });\n            \n            // Store location mapping\n            locationToReportId[locationHash] = reportId;\n            \n            // Mark user as having reported this location\n            userReportedLocation[_msgSender()][reportId] = true;\n            \n            totalReports++;\n            \n            emit PotholeReported(reportId, _msgSender(), latitude, longitude, ipfsHash);\n            \n            return reportId;\n        }\n    }\n\n    // Municipal Management Functions\n    function updateReportStatus(\n        uint256 reportId,\n        PotholeStatus newStatus\n    ) external onlyMunicipalAuthority validReportId(reportId) {\n        _updateReportStatus(reportId, newStatus, _msgSender(), \"\");\n    }\n\n    function batchUpdateStatus(\n        uint256[] calldata reportIds,\n        PotholeStatus newStatus\n    ) external onlyMunicipalAuthority {\n        address updatedBy = _msgSender();\n        for (uint256 i = 0; i < reportIds.length; i++) {\n            uint256 reportId = reportIds[i];\n            if (reportId > 0 && reportId < nextReportId && reports[reportId].status != newStatus) {\n                _updateReportStatus(reportId, newStatus, updatedBy, \"\");\n            }\n        }\n    }\n\n    // Internal function containing the core update logic\n    function _updateReportStatus(\n        uint256 reportId,\n        PotholeStatus newStatus,\n        address updatedBy,\n        string memory reason\n    ) internal {\n        require(reportId > 0 && reportId < nextReportId, \"Invalid report ID\");\n\n        PotholeStatus oldStatus = reports[reportId].status;\n        require(oldStatus != newStatus, \"Status unchanged\");\n        require(oldStatus != PotholeStatus.Rejected, \"Cannot update rejected pothole\");\n        require(oldStatus != PotholeStatus.Completed, \"Cannot update completed pothole\");\n\n        reports[reportId].status = newStatus;\n\n        if(newStatus == PotholeStatus.InProgress) {\n            // Reward original reporter once in progress\n            if (originalReportReward > 0) {\n                potholeToken.mint(reports[reportId].reporter, originalReportReward);\n            }\n        }\n        if(newStatus == PotholeStatus.Completed) {\n            // Reward original reporter once completed\n            if (originalReportFixedReward > 0) {\n                potholeToken.mint(reports[reportId].reporter, originalReportFixedReward);\n            }\n        }\n        if(newStatus == PotholeStatus.Rejected) {\n            // Emit rejection event with reason\n            emit PotholeRejected(reportId, updatedBy, reason);\n        }\n\n        emit PotholeStatusUpdated(reportId, oldStatus, newStatus, updatedBy);\n    }\n\n    // View Functions\n    function getReport(uint256 reportId) \n        external view validReportId(reportId) \n        returns (PotholeReport memory) {\n        return reports[reportId];\n    }\n\n    function getReportsBatch(\n        uint256[] calldata reportIds\n    ) external view returns (PotholeReport[] memory) {\n        PotholeReport[] memory result = new PotholeReport[](reportIds.length);\n        \n        for (uint256 i = 0; i < reportIds.length; i++) {\n            if (reportIds[i] > 0 && reportIds[i] < nextReportId) {\n                result[i] = reports[reportIds[i]];\n            }\n            // Invalid IDs return empty struct (default values)\n        }\n        \n        return result;\n    }\n    \n    function getTotalReports() external view returns (uint256) {\n        return nextReportId - 1;\n    }\n    \n    function getPriorityScore(uint256 reportId) \n        external view validReportId(reportId) \n        returns (uint256) {\n        return reports[reportId].duplicateCount;\n    }\n    \n    function hasUserReported(address user, uint256 reportId) \n        external view returns (bool) {\n        return userReportedLocation[user][reportId];\n    }\n\n    // Internal Functions\n    function _getLocationHash(int256 lat, int256 lng) \n        internal view returns (bytes32) {\n        // Assuming coordinates are in microdegrees (1e-6 degrees)\n        // 1 degree of latitude ~ 111 km\n        // 1 degree of longitude ~ 111 km * cos(latitude)\n        // In a real-world scenario, consider using a more accurate method.\n        // Convert coordinates to grid cells using fixed precision\n        int256 gridLat = lat / int256(grid_precision);\n        int256 gridLng = lng / int256(grid_precision);\n\n        return keccak256(abi.encodePacked(gridLat, gridLng));\n    }\n\n    // Admin Functions\n    function updateRewardSettings(\n        uint256 _originalReportReward,\n        uint256 _duplicateReporterReward,\n        uint256 _originalReportFixedReward\n    ) external onlyOwner {\n        originalReportReward = _originalReportReward;\n        duplicateReporterReward = _duplicateReporterReward;\n        originalReportFixedReward = _originalReportFixedReward;\n        \n        emit RewardSettingsUpdated(\n            _originalReportReward,\n            _duplicateReporterReward,\n            _originalReportFixedReward\n        );\n    }\n    \n    // Emergency Functions\n    function pause() external onlyOwner {\n        // Could add pausable functionality if needed\n        // For now, just owner can manage critical functions\n    }\n    \n    // Context override for ERC2771\n    function _msgSender() internal view override(Context, ERC2771Context) returns (address) {\n        return ERC2771Context._msgSender();\n    }\n    \n    function _msgData() internal view override(Context, ERC2771Context) returns (bytes calldata) {\n        return ERC2771Context._msgData();\n    }\n\n    function _contextSuffixLength() internal view override(Context, ERC2771Context) returns (uint256) {\n        return ERC2771Context._contextSuffixLength();\n    }\n}"
      }
    }
  }
}